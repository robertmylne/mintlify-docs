---
title: 'Sorting'
description: 'How to sort API response data using query parameters'
---

## Overview

The API supports sorting to help you organize response data in the order that best suits your needs. Use the `sort` and `order` query parameters to control how results are sorted.

## Basic Sorting

### Single Field Sorting

Sort by a single field using the `sort` parameter:

```bash
# Sort users by name
GET /api/v1/users?sort=name

# Sort orders by creation date
GET /api/v1/orders?sort=created_at

# Sort products by price
GET /api/v1/products?sort=price
```

### Sort Direction

Control sort direction using the `order` parameter:

```bash
# Ascending order (default)
GET /api/v1/users?sort=name&order=asc

# Descending order
GET /api/v1/users?sort=created_at&order=desc
```

| Order Value | Direction | Example |
|-------------|-----------|---------|
| `asc` | Ascending (A-Z, 0-9, oldest first) | Default behavior |
| `desc` | Descending (Z-A, 9-0, newest first) | Reverse order |

## Multi-Field Sorting

### Multiple Sort Fields

Sort by multiple fields using comma-separated values:

```bash
# Sort by status first, then by created_at
GET /api/v1/orders?sort=status,created_at&order=asc,desc

# Sort by priority, then name, then created_at
GET /api/v1/tasks?sort=priority,name,created_at&order=desc,asc,desc
```

### Order Parameter for Multiple Fields

When sorting by multiple fields, you can specify the order for each field:

- **Same order for all fields**: `order=desc`
- **Different order per field**: `order=desc,asc,desc`
- **Mixed specification**: `order=desc,asc` (remaining fields use `asc`)

```bash
# All fields descending
GET /api/v1/users?sort=status,created_at&order=desc

# Status ascending, created_at descending
GET /api/v1/users?sort=status,created_at&order=asc,desc

# Status descending, name ascending (order defaults to asc for name)
GET /api/v1/users?sort=status,name&order=desc
```

## Sortable Fields

### Common Sortable Fields

Most endpoints support sorting by these common fields:

| Field | Type | Description |
|-------|------|-------------|
| `id` | integer | Unique identifier |
| `created_at` | datetime | Creation timestamp |
| `updated_at` | datetime | Last modification timestamp |
| `name` | string | Name or title field |
| `status` | string | Status field |

### Endpoint-Specific Fields

Each endpoint may have additional sortable fields:

```bash
# Users endpoint
GET /api/v1/users?sort=email
GET /api/v1/users?sort=last_login
GET /api/v1/users?sort=role

# Products endpoint
GET /api/v1/products?sort=price
GET /api/v1/products?sort=category
GET /api/v1/products?sort=stock_quantity

# Orders endpoint
GET /api/v1/orders?sort=total_amount
GET /api/v1/orders?sort=customer_id
GET /api/v1/orders?sort=order_status
```

## Nested Field Sorting

Sort by nested object properties using dot notation:

```bash
# Sort by nested address field
GET /api/v1/users?sort=address.city

# Sort by customer name in orders
GET /api/v1/orders?sort=customer.name

# Sort by product category
GET /api/v1/products?sort=metadata.category
```

## Combining with Other Parameters

Sorting works seamlessly with filtering and pagination:

```bash
# Filter active users, sort by name, paginate results
GET /api/v1/users?status=active&sort=name&order=asc&limit=20&offset=0

# Complex query with multiple parameters
GET /api/v1/orders?customer_id=123&status_in=pending,processing&sort=created_at,total_amount&order=desc,asc&limit=50
```

## Response Format

Sorted responses include metadata about the applied sorting:

```json
{
  "data": [
    {
      "id": 1,
      "name": "Alice Johnson",
      "status": "active",
      "created_at": "2024-01-15T14:30:00.000Z"
    },
    {
      "id": 2,
      "name": "Bob Smith",
      "status": "active",
      "created_at": "2024-01-14T10:15:00.000Z"
    }
  ],
  "pagination": {
    "limit": 20,
    "offset": 0,
    "total": 150,
    "has_more": true
  },
  "sorting": {
    "fields": ["status", "name"],
    "order": ["asc", "asc"]
  }
}
```

## Default Sorting

### Default Behavior

When no sorting is specified, endpoints use these defaults:

- **Primary default**: `created_at desc` (newest first)
- **Secondary default**: `id desc` (highest ID first)

```bash
# These are equivalent
GET /api/v1/users
GET /api/v1/users?sort=created_at&order=desc
```

### Stable Sorting

To ensure consistent pagination, the API automatically adds `id` as a secondary sort field:

```bash
# Requested
GET /api/v1/users?sort=name

# Actually applied
sort=name,id&order=asc,asc
```

This prevents inconsistent ordering when multiple records have the same name value.

## Performance Considerations

### Indexed Fields

Sorting performance varies by field. These fields are typically indexed for fast sorting:

- `id`
- `created_at`
- `updated_at`
- `status`
- Primary identifier fields (e.g., `user_id`, `customer_id`)

### Optimization Tips

```bash
# ✅ Fast - sorts by indexed fields
GET /api/v1/users?sort=created_at&order=desc

# ⚠️ Slower - sorts by non-indexed string field
GET /api/v1/users?sort=description&order=asc

# ✅ Better - combine with filters to reduce dataset size
GET /api/v1/users?status=active&sort=description&order=asc
```

## Error Handling

### Invalid Sort Fields

```json
{
  "error": {
    "code": "validation_error",
    "message": "Invalid sort parameters",
    "details": {
      "sort": "Field 'invalid_field' is not sortable for this endpoint"
    }
  }
}
```

### Invalid Order Values

```json
{
  "error": {
    "code": "validation_error",
    "message": "Invalid sort parameters",
    "details": {
      "order": "Order must be 'asc' or 'desc', got 'invalid'"
    }
  }
}
```

### Mismatched Parameters

```json
{
  "error": {
    "code": "validation_error",
    "message": "Sort and order parameter count mismatch",
    "details": {
      "sort": "3 fields specified",
      "order": "2 order values specified"
    }
  }
}
```

## Advanced Examples

### E-commerce Product Listing

```bash
# Products by popularity (high to low), then by price (low to high)
GET /api/v1/products?sort=popularity_score,price&order=desc,asc

# In-stock products by newest first
GET /api/v1/products?stock_quantity_gt=0&sort=created_at&order=desc
```

### User Management

```bash
# Active users by last login (most recent first)
GET /api/v1/users?status=active&sort=last_login&order=desc

# Users by role hierarchy, then alphabetically
GET /api/v1/users?sort=role_priority,name&order=asc,asc
```

### Order Processing

```bash
# Pending orders by priority, then by creation date
GET /api/v1/orders?status=pending&sort=priority,created_at&order=desc,asc

# Orders by customer, then by total amount
GET /api/v1/orders?sort=customer.name,total_amount&order=asc,desc
```

## Best Practices

### Client Implementation

```javascript
// Helper function to build sort parameters
function buildSortQuery(sorts) {
  const sortFields = sorts.map(s => s.field).join(',');
  const sortOrders = sorts.map(s => s.order || 'asc').join(',');

  return {
    sort: sortFields,
    order: sortOrders
  };
}

// Usage
const sortConfig = [
  { field: 'status', order: 'asc' },
  { field: 'created_at', order: 'desc' }
];

const params = buildSortQuery(sortConfig);
// { sort: 'status,created_at', order: 'asc,desc' }
```

### Performance Guidelines

- **Limit complex sorts** on large datasets
- **Use filters** to reduce data before sorting
- **Prefer indexed fields** for primary sort criteria
- **Cache sorted results** when possible
- **Consider pagination** with consistent sort orders

<Note>
Check the specific endpoint documentation for the complete list of sortable fields, as they may vary between endpoints.
</Note>

<Tip>
When implementing table sorting in your UI, always include the `id` field as a secondary sort to ensure consistent pagination behavior.
</Tip>